/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "dDS.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

dDSStatus *
ddsrequest_1(dDSCommand *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSREQUEST,
		(xdrproc_t) xdr_dDSCommand, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssource_1(dDSSource *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSOURCE,
		(xdrproc_t) xdr_dDSSource, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSFringeRates *
ddsrates_1(dDSCommand *argp, CLIENT *clnt)
{
	static dDSFringeRates clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSRATES,
		(xdrproc_t) xdr_dDSCommand, (caddr_t) argp,
		(xdrproc_t) xdr_dDSFringeRates, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSInfo *
ddsinfo_1(dDSCommand *argp, CLIENT *clnt)
{
	static dDSInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSINFO,
		(xdrproc_t) xdr_dDSCommand, (caddr_t) argp,
		(xdrproc_t) xdr_dDSInfo, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssign_1(dDSSignChange *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSIGN,
		(xdrproc_t) xdr_dDSSignChange, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddsfrequency_1(dDSFrequency *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSFREQUENCY,
		(xdrproc_t) xdr_dDSFrequency, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssetbaselines_1(dDSBaselines *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSETBASELINES,
		(xdrproc_t) xdr_dDSBaselines, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSDelayValues *
ddsgetdelay_1(dDSDelayRequest *argp, CLIENT *clnt)
{
	static dDSDelayValues clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSGETDELAY,
		(xdrproc_t) xdr_dDSDelayRequest, (caddr_t) argp,
		(xdrproc_t) xdr_dDSDelayValues, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSBaselineReport *
ddsreportbaselines_1(dDSCommand *argp, CLIENT *clnt)
{
	static dDSBaselineReport clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSREPORTBASELINES,
		(xdrproc_t) xdr_dDSCommand, (caddr_t) argp,
		(xdrproc_t) xdr_dDSBaselineReport, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSuvw *
ddsgetuvw_1(dDSuvwRequest *argp, CLIENT *clnt)
{
	static dDSuvw clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSGETUVW,
		(xdrproc_t) xdr_dDSuvwRequest, (caddr_t) argp,
		(xdrproc_t) xdr_dDSuvw, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddsnddconfigure_1(dDSNDDConfig *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSNDDCONFIGURE,
		(xdrproc_t) xdr_dDSNDDConfig, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddsoffsetfreq_1(dDSFrequencyOff *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSOFFSETFREQ,
		(xdrproc_t) xdr_dDSFrequencyOff, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSToPAP *
ddspapupdate_1(pAPToDDS *argp, CLIENT *clnt)
{
	static dDSToPAP clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSPAPUPDATE,
		(xdrproc_t) xdr_pAPToDDS, (caddr_t) argp,
		(xdrproc_t) xdr_dDSToPAP, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssetoffsets_1(dDSRateOffsets *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSETOFFSETS,
		(xdrproc_t) xdr_dDSRateOffsets, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssetwalshers_1(dDSWalshers *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSETWALSHERS,
		(xdrproc_t) xdr_dDSWalshers, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSStatus *
ddssetrotators_1(dDSRotators *argp, CLIENT *clnt)
{
	static dDSStatus clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSSETROTATORS,
		(xdrproc_t) xdr_dDSRotators, (caddr_t) argp,
		(xdrproc_t) xdr_dDSStatus, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dDSWalshPackage *
ddsgetwalshpatterns_1(dDSCommand *argp, CLIENT *clnt)
{
	static dDSWalshPackage clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, DDSGETWALSHPATTERNS,
		(xdrproc_t) xdr_dDSCommand, (caddr_t) argp,
		(xdrproc_t) xdr_dDSWalshPackage, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
