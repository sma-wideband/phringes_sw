/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "dDS.h"

bool_t
xdr_dDSStatus (XDR *xdrs, dDSStatus *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->reason))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSBaselines (XDR *xdrs, dDSBaselines *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSBaselineReport (XDR *xdrs, dDSBaselineReport *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->antenna, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->antenna;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->antenna, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->antenna;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_vector (xdrs, (char *)objp->antenna, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSSource (XDR *xdrs, dDSSource *objp)
{
	register int32_t *buf;

	 if (!xdr_double (xdrs, &objp->hourAngle))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->declination))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSFrequency (XDR *xdrs, dDSFrequency *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->gunnMultiple;
					i < DDS_N_RECEIVERS; ++i) {
					IXDR_PUT_LONG(buf, *genp++);
				}
			}
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->gunnMultiple;
					i < DDS_N_RECEIVERS; ++i) {
					*genp++ = IXDR_GET_LONG(buf);
				}
			}
		}
	 return TRUE;
	}

	 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSFringeRates (XDR *xdrs, dDSFringeRates *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->rate1, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->rate2, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSCommand (XDR *xdrs, dDSCommand *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->command))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->antenna))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->receiver))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->command);
		IXDR_PUT_LONG(buf, objp->antenna);
		IXDR_PUT_LONG(buf, objp->receiver);
		}
		 if (!xdr_double (xdrs, &objp->refFrequency))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRate1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRate2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->phase1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->phase2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->client, 20,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->command))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->antenna))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->receiver))
				 return FALSE;

		} else {
		objp->command = IXDR_GET_LONG(buf);
		objp->antenna = IXDR_GET_LONG(buf);
		objp->receiver = IXDR_GET_LONG(buf);
		}
		 if (!xdr_double (xdrs, &objp->refFrequency))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRate1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRate2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->phase1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->phase2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->client, 20,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->command))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->antenna))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->receiver))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->refFrequency))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->fringeRate1, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->fringeRate2, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->phase1, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->phase2, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->client, 20,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSInfo (XDR *xdrs, dDSInfo *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_int (xdrs, &objp->validPosition))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->hardwareEnabled))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->gunnMultiple;
				i < DDS_N_RECEIVERS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_double (xdrs, &objp->hourAngle))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->declination))
			 return FALSE;
		buf = XDR_INLINE (xdrs, (2 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->frequencySign))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->phaseSign))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->dDS1Exists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->frequencySign);
		IXDR_PUT_LONG(buf, objp->phaseSign);
		{
			register int *genp;

			for (i = 0, genp = objp->dDS1Exists;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->dDS1Rate, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->dDS1Phase, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->dDS2Exists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->dDS2Exists;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->dDS2Rate, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->dDS2Phase, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, (1 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->delayTracking))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->pattern, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->delayTracking);
		{
			register int *genp;

			for (i = 0, genp = objp->pattern;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->delay, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->baseline, DDS_N_BASELINES,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_int (xdrs, &objp->validPosition))
			 return FALSE;
		 if (!xdr_int (xdrs, &objp->hardwareEnabled))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->gunnMultiple;
				i < DDS_N_RECEIVERS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_double (xdrs, &objp->hourAngle))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->declination))
			 return FALSE;
		buf = XDR_INLINE (xdrs, (2 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->frequencySign))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->phaseSign))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->dDS1Exists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		objp->frequencySign = IXDR_GET_LONG(buf);
		objp->phaseSign = IXDR_GET_LONG(buf);
		{
			register int *genp;

			for (i = 0, genp = objp->dDS1Exists;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->dDS1Rate, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->dDS1Phase, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->dDS2Exists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->dDS2Exists;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->dDS2Rate, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->dDS2Phase, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, (1 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->delayTracking))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->pattern, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		objp->delayTracking = IXDR_GET_LONG(buf);
		{
			register int *genp;

			for (i = 0, genp = objp->pattern;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->delay, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->baseline, DDS_N_BASELINES,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->validPosition))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->hardwareEnabled))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->frequency, DDS_N_RECEIVERS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->hourAngle))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->declination))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->frequencySign))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->phaseSign))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS1Exists, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS1Rate, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS1Phase, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS2Exists, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS2Rate, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->dDS2Phase, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->delayTracking))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->pattern, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delay, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->baseline, DDS_N_BASELINES,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSSignChange (XDR *xdrs, dDSSignChange *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->frequencySign))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->phaseSign))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSDelayRequest (XDR *xdrs, dDSDelayRequest *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->nWalsh))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->startTime))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSDelayValues (XDR *xdrs, dDSDelayValues *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (1 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->status);
		{
			register int *genp;

			for (i = 0, genp = objp->antennaExists;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_double (xdrs, &objp->delayHA))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delaySec, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayConst1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayConst2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delaySin, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayCos, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (1 + ( DDS_N_ANTENNAS )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		objp->status = IXDR_GET_LONG(buf);
		{
			register int *genp;

			for (i = 0, genp = objp->antennaExists;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_double (xdrs, &objp->delayHA))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delaySec, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayConst1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayConst2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delaySin, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->delayCos, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->delayHA))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delaySec, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delayConst1, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delayConst2, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delaySin, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->delayCos, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSuvw (XDR *xdrs, dDSuvw *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_vector (xdrs, (char *)objp->u, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->v, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->w, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefLongitude))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefLatitude))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefElevation))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fixedDelays, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->dayFraction))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->UT1MinusUTC))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->lST))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->hourAngle))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->declination))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->trackingFrequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->gunnMultiple;
				i < DDS_N_RECEIVERS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->fringeRates1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRates2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_vector (xdrs, (char *)objp->u, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->v, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->w, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefLongitude))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefLatitude))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->arrayRefElevation))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fixedDelays, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->dayFraction))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->UT1MinusUTC))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->lST))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->hourAngle))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->declination))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->trackingFrequency, DDS_N_RECEIVERS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_RECEIVERS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->gunnMultiple;
				i < DDS_N_RECEIVERS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->fringeRates1, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->fringeRates2, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_vector (xdrs, (char *)objp->u, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->v, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->w, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->X, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Y, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->Z, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->arrayRefLongitude))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->arrayRefLatitude))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->arrayRefElevation))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->fixedDelays, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->dayFraction))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->UT1MinusUTC))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->lST))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->hourAngle))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->declination))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->trackingFrequency, DDS_N_RECEIVERS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->gunnMultiple, DDS_N_RECEIVERS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->fringeRates1, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->fringeRates2, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSuvwRequest (XDR *xdrs, dDSuvwRequest *objp)
{
	register int32_t *buf;

	 if (!xdr_double (xdrs, &objp->UTC))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSNDDConfig (XDR *xdrs, dDSNDDConfig *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tone))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->inject))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->noiseAnt1))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->noiseAnt2))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->tone);
		IXDR_PUT_LONG(buf, objp->inject);
		IXDR_PUT_LONG(buf, objp->noiseAnt1);
		IXDR_PUT_LONG(buf, objp->noiseAnt2);
		}
		 if (!xdr_float (xdrs, &objp->noise1Atten))
			 return FALSE;
		 if (!xdr_float (xdrs, &objp->noise2Atten))
			 return FALSE;
		 if (!xdr_float (xdrs, &objp->noise3Atten))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->tone))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->inject))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->noiseAnt1))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->noiseAnt2))
				 return FALSE;

		} else {
		objp->tone = IXDR_GET_LONG(buf);
		objp->inject = IXDR_GET_LONG(buf);
		objp->noiseAnt1 = IXDR_GET_LONG(buf);
		objp->noiseAnt2 = IXDR_GET_LONG(buf);
		}
		 if (!xdr_float (xdrs, &objp->noise1Atten))
			 return FALSE;
		 if (!xdr_float (xdrs, &objp->noise2Atten))
			 return FALSE;
		 if (!xdr_float (xdrs, &objp->noise3Atten))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->tone))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->inject))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->noiseAnt1))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->noiseAnt2))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->noise1Atten))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->noise2Atten))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->noise3Atten))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSFrequencyOff (XDR *xdrs, dDSFrequencyOff *objp)
{
	register int32_t *buf;

	 if (!xdr_double (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_pAPToDDS (XDR *xdrs, pAPToDDS *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->phaseOffsets, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSToPAP (XDR *xdrs, dDSToPAP *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_double (xdrs, &objp->rA))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refLat))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refLong))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refRad))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->antennaExists;
				i < DDS_N_ANTENNAS; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->a, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->b, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->c, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_double (xdrs, &objp->rA))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refLat))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refLong))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->refRad))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->antennaExists;
				i < DDS_N_ANTENNAS; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->a, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->b, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->c, DDS_N_ANTENNAS,
			sizeof (double), (xdrproc_t) xdr_double))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_double (xdrs, &objp->rA))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->refLat))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->refLong))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->refRad))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->antennaExists, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->a, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->b, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->c, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSRateOffsets (XDR *xdrs, dDSRateOffsets *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->offset, DDS_N_ANTENNAS,
		sizeof (double), (xdrproc_t) xdr_double))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSWalshers (XDR *xdrs, dDSWalshers *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->shouldWalsh, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->shouldWalsh;
					i < DDS_N_ANTENNAS; ++i) {
					IXDR_PUT_LONG(buf, *genp++);
				}
			}
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->shouldWalsh, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->shouldWalsh;
					i < DDS_N_ANTENNAS; ++i) {
					*genp++ = IXDR_GET_LONG(buf);
				}
			}
		}
	 return TRUE;
	}

	 if (!xdr_vector (xdrs, (char *)objp->shouldWalsh, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSRotators (XDR *xdrs, dDSRotators *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->shouldRotate, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->shouldRotate;
					i < DDS_N_ANTENNAS; ++i) {
					IXDR_PUT_LONG(buf, *genp++);
				}
			}
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, ( DDS_N_ANTENNAS ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->shouldRotate, DDS_N_ANTENNAS,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
		} else {
			{
				register int *genp;

				for (i = 0, genp = objp->shouldRotate;
					i < DDS_N_ANTENNAS; ++i) {
					*genp++ = IXDR_GET_LONG(buf);
				}
			}
		}
	 return TRUE;
	}

	 if (!xdr_vector (xdrs, (char *)objp->shouldRotate, DDS_N_ANTENNAS,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSWalshPattern (XDR *xdrs, dDSWalshPattern *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->step.step_val, (u_int *) &objp->step.step_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dDSWalshPackage (XDR *xdrs, dDSWalshPackage *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_array (xdrs, (char **)&objp->pattern.pattern_val, (u_int *) &objp->pattern.pattern_len, ~0,
			sizeof (dDSWalshPattern), (xdrproc_t) xdr_dDSWalshPattern))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->interleave))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->walshCycleTime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startYear))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startDay))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startHour))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startMin))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startSec))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startuSec))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->interleave);
			IXDR_PUT_LONG(buf, objp->walshCycleTime);
			IXDR_PUT_LONG(buf, objp->startYear);
			IXDR_PUT_LONG(buf, objp->startDay);
			IXDR_PUT_LONG(buf, objp->startHour);
			IXDR_PUT_LONG(buf, objp->startMin);
			IXDR_PUT_LONG(buf, objp->startSec);
			IXDR_PUT_LONG(buf, objp->startuSec);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_array (xdrs, (char **)&objp->pattern.pattern_val, (u_int *) &objp->pattern.pattern_len, ~0,
			sizeof (dDSWalshPattern), (xdrproc_t) xdr_dDSWalshPattern))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->interleave))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->walshCycleTime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startYear))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startDay))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startHour))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startMin))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startSec))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->startuSec))
				 return FALSE;
		} else {
			objp->interleave = IXDR_GET_LONG(buf);
			objp->walshCycleTime = IXDR_GET_LONG(buf);
			objp->startYear = IXDR_GET_LONG(buf);
			objp->startDay = IXDR_GET_LONG(buf);
			objp->startHour = IXDR_GET_LONG(buf);
			objp->startMin = IXDR_GET_LONG(buf);
			objp->startSec = IXDR_GET_LONG(buf);
			objp->startuSec = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_array (xdrs, (char **)&objp->pattern.pattern_val, (u_int *) &objp->pattern.pattern_len, ~0,
		sizeof (dDSWalshPattern), (xdrproc_t) xdr_dDSWalshPattern))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->interleave))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->walshCycleTime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startYear))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startDay))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startHour))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startMin))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startSec))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->startuSec))
		 return FALSE;
	return TRUE;
}
